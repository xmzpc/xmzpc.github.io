---
layout: post
title: Java代码是怎么运行的？
category: jvm
tags: [jvm]
lock: need
excerpt: Java 代码有很多种不同的运行方式，比如在开发工具中运行、双击执行 jar 文件运行、在命令行中运行，甚至可以在网页中运行。
---

## Java 和 C++ 在运行方式上的区别？
Java 代码有很多种不同的运行方式，比如在开发工具中运行、双击执行 jar 文件运行、在命令行中运行，甚至可以在网页中运行。

> Java 的运行离不开 JRE（Java 运行时环境）， JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。当然我们程序员更经常接触到的是 JDK（Java 开发工具包），包含了JRE，并且还附带了一系列开发、诊断工具。
>

运行 C++ 代码则无需额外的运行时，往往把代码直接编译成 CPU 所能理解的机器码即可。

## 为什么 Java 要在虚拟机里运行？
Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。

所以可以在 Java 代码与机器码之间加一层虚拟机，先将 Java 代码转换成 Java 字节码，最后才转换成机器码，降低复杂度。

Java Hello World 字节码格式

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191029151736.png)

## Java 虚拟机的好处
- 通过为各个平台（Linux、Windows、Mac os等）提供Java虚拟机的软件实现，在各个平台上都可以将Java代码转换成字节码来运行Java（**可移植性**），达到 “一次编写、到处运行” 的目的
- Java虚拟机为我们带来了一个托管环境（Managed Runtime），可以替我们处理一些冗长而且容易出错的代码，最重要的譬如自动内存管理与垃圾回收，同时还提供诸如数组越界、动态类型、安全权限等的动态检测，让我们可以专心的写业务代码


## Java 虚拟机具体是怎样运行 Java 字节码的？
首先从虚拟机的角度来看：

1. 首先将 Java 代码编译成的 class 文件
2. 将 class 文件加载到 Java 虚拟机中（载入Java内存），加载后的 Java 类会被存放于方法区（Method Area）中
3. 运行时，虚拟机执行方法区内的代码

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191029151838.png)

Java 虚拟机会**将栈细分为**面向 Java 方法的 **Java 方法栈**，面向本地方法（用 C++ 写的 native 方法）的**本地方法栈**，以及存放各个线程执行位置的PC 寄存器。

> 本地方法，用关键字 native 修饰，基于JNI（Java Native Interface，Java本地接口），它允许 Java 代码和其他语言写的代码进行交互

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个**栈帧**，用以存放局部变量以及字节码的操作数。（栈帧是提前计算好且不需连续分布）

当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会**弹出当前线程的当前栈帧**，并将之舍弃。

Java 虚拟机将字节码翻译成机器码有两种形式：

1. 解释执行：即逐条将字节码翻译成机器码并执行；
2. 即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191029152016.png)

解释执行的好处是**无须等待编译**，即时编译的好处是**实际执行速度更快**。

HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点，它会先解释执行字节码，然后将其中反复执行的**热点代码**，**以方法为单位进行即时编译**。

## 关于即时编译
即时编译主要是为了提高 Java 虚拟机的启动性能以及峰值性能，它建立在程序符合**二八定律**的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。

对于百分之八十（大部分）不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；对于百分之二十（小部分）的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。

为了满足不同用户场景的需要（在编译时间和生成代码的执行效率之间进行取舍），HotSpot 内置了多个即时编译器：C1、C2 和 Graal

- C1，又叫 **Client** 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的**优化手段相对简单**，编译时间较短。
- C2，又叫 **Server** 编译器，面向的是对峰值性能有要求的服务器端程序，采用的**优化手段相对复杂**，编译时间较长，但同时生成代码的执行效率较高。
- Graal 是Java 10 正式引入的实验性即时编译器

从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。

## 参考

[Java代码是怎么运行的？](https://blog.csdn.net/wwwdc1012/article/details/83759500)