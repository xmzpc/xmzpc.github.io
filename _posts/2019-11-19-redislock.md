---
layout: post
title: Redis分布式锁的实现
category: redis
tags: [redis]
lock: need
excerpt: 这篇博文讲介绍如何一步步构建一个基于Redis的分布式锁。会从最原始的版本开始，然后根据问题进行调整，最后完成一个较为合理的分布式锁。
---

## 分布式锁

### 概念

分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。

### 条件

- 互斥性：在任意一个时刻，只有一个客户端持有锁。
- 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
- 解锁：解铃还须系铃人，加锁和解锁必须是同一个客户端，客户端A的线程加的锁必须是客户端A的线程来解锁，客户端不能解开别的客户端的锁。
- 可重入：当一个客户端获取对象锁之后，这个客户端可以再次获取这个对象上的锁。

### 实现方式

1. 数据库
2. Memcached（add命令）
3. Redis（setnx命令）
4. Zookeeper（临时节点）

### 为什么需要分布式锁

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201911/20191119091029.Png)

上图模拟了一个简单的分布式售票系统，三个售票窗口工用一个库存系统，在单机环境下，一个库存系统对应一个售票系统，此时使用synchronized或ReentrantLock即可保证系统线程安全，**但并不能保证分布式的线程安全，**因为每一个购票系统都有各自的JVM进程，互相独立。所以需要对于三个系统都是**公共的一个中间件**来解决这个问题。

##  Redis分布式锁进化过程

### 最基础的版本-set

实现分布式锁只需要对共享变量控制到位即可，而且要保证整个系统（多个进程）内只有这一份即可。

所以使用redis的基础命令get/set/del即可实现最基础的分布式锁。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201911/20191119092523.Png)

在获取锁之前先`get lock_ticket`看这个锁存不存在，如果不存在则再`set lock_ticket value`，如果存在则等待一段时间后再重试，最后使用完成了再删除这个锁`del lock_ticket`即可。

但是，这种方案有个问题，如果一开始这个锁是不存在的，两个线程去同时get，这个时候返回的都是null（nil），然后这两个线程都去set，这时候就出问题了，两个线程都可以set成功，相当于两个线程都获取到同一个锁了。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201911/20191119093820.Png)

### 进化版1-setnx

`setnx`这个命令，它是`set if not exist`的缩写，也就是如果不存在就set。当重复对同一个key进行setnx的时候，只有第一次是可以成功的。但是，这种方案也有个问题，如果获取锁的这个客户端断线了怎么办？这个锁不是一直都不会释放吗？是的，是这样的。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201911/20191119094347.Png)

所以，这种方案也不可行！

### 进化版2-setnx+setex

本方案就是先使用`setnx lock_ticket value`命令拿到锁，再立即使用`setex lock_ticket 30 value`设置过期时间，最后使用`del lock_ticket`释放锁。

但是如果setnx之后setex之前这个客户端就断线了呢...

### 进化版3-set nx ex

上面的方案不太好的主要原因是setnx/setex是两条独立的命令，无法解决前者成功之后客户端断线的问题，那么，把两条命令合在一起不就行了吗？

是的，redis官方也意识到这个问题了，所以2.6.12版本给set命令加了一些参数：

```
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

EX，过期时间，单位秒

PX，过期时间，单位毫秒

NX，not exist，如果不存在才设置成功

XX，exist exist？如果存在才设置成功

释放锁只要简单地执行`del lock_ticket`即可，并不会检查这个锁是不是当前客户端获取到的。

那么如何保证锁不会被误删除？

### 进化版4-random value + lua script

上面的方案不完美的主要原因是释放锁这里控制的还不是很到位，那么有没有其它方法可以控制释放锁的线程和加锁的线程一定是同一个客户端呢？

redis官方给出的方案是这样的：

```java
 // 加锁
 SET resource_name my_random_value NX PX 30000
 
 // 释放锁
 if redis.call("get",KEYS[1]) == ARGV[1] then
     return redis.call("del",KEYS[1])
 else
     return 0
 end
```

加锁的时候，设置随机值，保证这个随机值只有当前客户端自己知道。

释放锁的时候，执行一段lua脚本，把这段lua脚本当成一个完整的命令，先检查这个锁对应的值是不是上面设置的随机值，如果是再执行del释放锁，否则直接返回释放锁失败。

我们知道，redis是单线程的，所以这段lua脚本中的get和del不会存在并发问题，但是不能在java中先get再del，这样会当成两个命令，会有并发问题，lua脚本相当于是一个命令一起传输给redis的。

这种方案算是比较完美了，但是还有一点小缺陷，就是这个过期时间设置成多少合适呢？

设置的过小，有可能上一个线程还没执行完锁内逻辑，锁就自动释放了，导致另一个线程可以获取锁了，就出现并发问题了；

设置的过大，就要考虑客户端断线了，这个锁要等待很长一段时间。

所以，这里又衍生出一个新的问题，过期时间我设置小一点，但是快到期了它能自动续期就好了，还有就是可重入怎么解决。

### 最终版本-redisson

Redisson是Redis官方推荐的Java版的Redis客户端。它提供的功能非常多，也非常强大

Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201911/20191119095522.png)

## 总结

**redis分布式锁有哪些优点？**

答：1）大部分系统都依赖于redis做缓存，不需要额外依赖其它组件（相对于zookeeper来说）；

2）redis可以集群部署，相对于mysql的单点更可靠；

3）不会占用mysql的连接数，不会增加mysql的压力；

4）redis社区相对活跃，redisson的实现更是稳定可靠；

5）利用过期机制解决客户端断线的问题，虽然不太及时；

6）有现成的轮子redisson可以使用，锁的种类比较齐全；

**redis分布式锁有哪些缺点？**

答：1）集群模式下会在所有master节点执行加锁命令，大部分（2N+1）成功了则获得锁，节点越多，加锁的过程越慢；

2）高并发情况下，未获得锁的线程会睡眠重试，如果同一把锁竞争非常激烈，会占用非常多的系统资源；

3）历史原因导致的坑挺多的，自己很难实现出来健壮的redis分布式锁；

总之，redis分布式锁的优点是大于缺点的，而且社区活跃，这也是我们大部分系统使用redis作为分布式锁的原因。

## 参考

[死磕 java同步系列之redis分布式锁进化史](https://www.cnblogs.com/tong-yuan/p/11621361.html)

