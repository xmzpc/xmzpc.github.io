---
layout: post
title: JVM-垃圾收集
category: jvm
tags: [jvm]
lock: need
excerpt: Java语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源（尤其是内存资源）的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但同时，它也增加了软件系统的负担。一个不合适的垃圾回收方法和策略会对系统性能造成不良影响。
---

## 判断对象是否已死？

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能在被使用的。

优点：实现简单，判定效果高。

缺点：无法解决对象之间相互循环引用的问题。

### 可达性分析算法

了解可达性分析算法之前先了解一个概念——GC Roots，垃圾收集的起点，可以作为GC Roots的有虚拟机栈中本地变量表中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。 
当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就说明此对象是不可用的，是死对象。如下图：object1、object2、object3、object4和GC Roots之间有可达路径，这些对象不会被回收，但object5、object6、object7到GC Roots之间没有可达路径，这些对象就被判了死刑。 

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028134840.jpg)

上面被判了死刑的对象（object5、object6、object7）并不是必死无疑，还有挽救的余地。进行可达性分析后对象和GC Roots之间没有引用链相连时，对象将会被进行一次标记，接着会判断如果对象没有覆盖Object的finalize()方法或者finalize()方法已经被虚拟机调用过，那么它们就会被行刑（清除）；如果对象覆盖了finalize()方法且还没有被调用，则会执行finalize()方法中的内容，所以在finalize()方法中如果重新与GC Roots引用链上的对象关联就可以拯救自己，但是一般不建议这么做。

可以作为GC Root的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中Native方法引用的对象。

### 4种引用类型

| 引用类型 | 含义                                                         | 被引用对象何时被回收               |
| :------- | :----------------------------------------------------------- | :--------------------------------- |
| 强引用   | 代码中普遍使用的引用，如Object obj = new Object()            | 永远不会被回收                     |
| 软引用   | 描述一些有用但并非必须的对象                                 | 在系统将要发生内存溢出异常之前回收 |
| 弱引用   | 描述非必须对象，强度比软引用更弱                             | 对象只能生存在下次GC之前           |
| 虚引用   | 不会对对象生存时间构成影响，唯一目的是在对象被回收时收到一个系统通知 | 不一定                             |

### 回收方法区(永久代)

方法区也就是永久代的回收，主要回收两部分内容：废弃常量和无用的类。

常量池中的常量如果没有对象引用它，就会被回收。

无用类的判定：

- 该类所有实例都已被回收。
- 该类的ClassLoader已被回收。
- 该类的Class对象没有在任何地方被引用。

## 垃圾收集算法

常用的垃圾回收算法有三种：标记-清除算法、复制算法、标记-整理算法。

### 标记-清除算法

分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图。

缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028135234.jpg)

### 复制算法

将内存划分为大小相等的两块，每次使用其中一块，当一块内存用完了要进行垃圾回收时，将存活的对象复制到另一块内存上，然后把已经使用过的内存一次清理掉。

优点：每次对半块内存进行回收，不用考虑内存碎片的问题，实现简单高效。

缺点：将内存缩小为了原来的一半。 

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028135442.png)

### 标记-整理算法(Mark-Compart)

应用在老年代，标记所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028135547.jpg)

### 分代收集算法

把堆内存分为新生代和老年代，新生代又分为Eden区、From Survivor和To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收。 

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028135658.jpg)

> 补充说明：
>
> 新生代GC（Minor GC）：指发生在新生代的垃圾收集，由于Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也快。
>
> 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现Full GC经常会伴随至少一次Minor GC，Full GC速度一般会比Minor GC慢10倍以上。

## 垃圾收集器

- 按线程数分：

串行：串行垃圾回收器一次只使用一个线程继续垃圾回收。

并行：并行垃圾回收器一次开启多个线程同时进行垃圾回收。在cup能力较强时使用并行可以提高垃圾收集效率，缩短GC停顿时间。

- 按工作模式分：

并发式：并发式垃圾回收器与应用系统交替工作，以尽可能减少应用系统的停顿时间。

独占式：独占式垃圾回收器（Stop the World）一旦运行就停止应用程序运行，直到垃圾收集完全结束，才允许应用程序执行。

- 按碎片处理方式分：

压缩式：压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。

非压缩式：非压缩式垃圾回收器不进行压缩操作。

- 按工作内存区间分：

新生代垃圾回收器：只在新生代工作。

老年代垃圾回收器：只在老年代工作。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028140004.png)

### CMS收集器

CMS(Concurrent Mark Sweep)是一种以获取**最短回收停顿**时间为目标的**老年代**收集器。CMS非常适合用于互联网站或者B/S系统服务器上，这类应用重视服务响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

CMS收集器基于标记-清除算法，它的运作过程更复杂一点，分为4个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark)
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

初始标记、重新标记两个步骤需要”Stop The World“，初始标记仅仅标记GC Root直接关联对象，速度很快。

并发标记阶段要进行可达性分析，耗时最长。

重新标记是为了修正并发标记期间用户对标记对象做的更改，耗时比初始标记长但远比并发标记短。

由于整个过程中耗时最长的**并发标记**和**并发清除**过程收集器线程都与用户线程并发工作，所以从总体上来看，CMS收集器的回收过程是与用户线程并发执行的。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028140243.png)

CMS收集器也存在一些缺点：

- 对CPU资源敏感：默认分配的垃圾收集线程数为（CPU数+3）/4，随着CPU数量下降，占用CPU资源越多，吞吐量越小
- 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当CMS运行时，预留的内存空间无法满足用户线程的需要，就会出现“Concurrent Mode Failure”的错误，这时将会启动后备预案，临时用Serial Old来重新进行老年代的垃圾收集。
- 因为CMS是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过-XX:UserCMSCompactAtFullCollection开启碎片整理（默认开启），在CMS进行Full GC之前，会进行内存碎片的整理。还可以用-XX:CMSFullGCsBeforeCompaction设置执行多少次不压缩（不进行碎片整理）的Full GC之后，跟着来一次带压缩（碎片整理）的Full GC。 
  适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用-XX:+UserConMarkSweepGC来选择CMS作为老年代收集器。

### G1收集器

G1（Garbage First）收集器在JDK 1.7中发布，目标是作为一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是在未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：

- **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- **分代收集**：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。
- **空间整合**：G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
- **可预测的停顿**：这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它**将整个Java堆划分为多个大小相等的独立区域**（Region） ，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。

G1收集器之所以能**建立可预测的停顿时间模型**，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表 ，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![](https://raw.githubusercontent.com/xmzpc/PicBed/master/img/201910/20191028140443.png)

## 内存分配与回收策略

Java中的自动内存管理最终可以归结为自动化地解决两个问题：

**1. 给对象分配内存。**

**2. 回收分配给对象的内存。**

大体来讲对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况下也有可能直接分配在老年代中。

普遍内存分配规则：

### 1. 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有狗狗空间进行分配时，虚拟机将发起一次 Minor GC。

### 2. 大对象直接进入老年代

大对象指需要大量连续内存空间的Java对象，比如很长的字符串或者数组，大对象对虚拟机来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置他们。

`-XX:PretenureSizeThreshold`指定对象大于这个值的时候直接在老年代分配。

### 3. 长期存活的对象将进入老年代

JVM会给每个对象定义一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后存活，并被移动到Survivor空间，那么对象年龄设为1，对象在Survivor中每熬过一次Minor GC，年龄就加1，当年龄增长到一定程度（默认为15岁），就将会被晋升到老年代中，对象晋升年龄的阀值通过`-XX:MaxTenuringThreshold`设置。

### 4. 动态对象年龄判定

如果在Survivor空间中相同年龄的对象占用空间的的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。

### 5. 空间分配担保

在发生Minor GC之前，虚拟机会检查**老年代最大可用的连续空间**是否大于**新生代所有对象的总空间**，

- 如果大于，则此次**Minor GC是安全的**
- 如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。
   如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

上面提到了Minor GC依然会有风险，是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。

取平均值仍然是一种**概率性的事件**，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败，如果出现了分配担保失败，**就只能在失败后重新发起一次Full GC**。虽然存在发生这种情况的概率，但**大部分时候都是能够成功分配担保**的，这样就避免了过于频繁执行Full GC。

## 参考

[深入理解Java虚拟机 JVM高级特性与最佳实践（第二版）]()